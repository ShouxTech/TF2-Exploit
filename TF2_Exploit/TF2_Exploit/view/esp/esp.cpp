#include "esp.h"
#include "../../model/get_valid_players/get_valid_players.h"
#include "../../model/world_to_screen_point/world_to_screen_point.h"
#include "../../model/globals/globals.h"

#include "../imgui/imgui.h"
#include "../imgui/backends/imgui_impl_dx9.h"
#include "../imgui/backends/imgui_impl_win32.h"

void draw_rect_using_dimensions(ImDrawList* drawList, const ImVec2& position, const ImVec2& dimensions, ImU32 color, float rounding, ImDrawFlags flags, float thickness, bool filled) {
    if (filled) {
        drawList->AddRectFilled(
            position,
            ImVec2(position.x + dimensions.x, position.y + dimensions.y),
            color,
            rounding,
            flags
        );
    } else {
        drawList->AddRect(
            position,
            ImVec2(position.x + dimensions.x, position.y + dimensions.y),
            color,
            rounding,
            flags,
            thickness
        );
    }
}


void esp::update() {
    ImDrawList* draw_list = ImGui::GetBackgroundDrawList();

    vengine* engine = globals::engine;
    ventity_list* entity_list = globals::entity_list;

    if (!engine->IsInGame()) return;

    player* local_player = static_cast<player*>(entity_list->GetClientEntity(engine->GetLocalPlayer()));

    if (!local_player) return;

    vector3 local_origin = local_player->get_origin();

    for (const auto& player : get_valid_players()) {
        vector3 origin = player->get_origin();
        vector3 head_origin = player->get_bone_origin(6);

        vector2 screen_origin_position = world_to_screen_point(origin);
        if (screen_origin_position.x == -1) continue;
        vector2 screen_head_origin_position = world_to_screen_point(head_origin);
        if (screen_head_origin_position.x == -1) continue;
        vector2 screen_head_origin_position_with_slight_offset = world_to_screen_point(head_origin + vector3(0, 0, 5));
        if (screen_head_origin_position_with_slight_offset.x == -1) continue;

        int distance = (origin - local_origin).get_magnitude();
        distance = distance == 0 ? 1 : distance;

        if (globals::esp_box_enabled) {
            int esp_box_thickness = 1;

            float height = screen_origin_position.y - screen_head_origin_position_with_slight_offset.y;
            float width = height / 2;

            draw_rect_using_dimensions( // Black outline.
                draw_list,
                ImVec2(screen_head_origin_position_with_slight_offset.x - (width / 2), screen_head_origin_position_with_slight_offset.y),
                ImVec2(width, height),
                ImColor(0.f, 0.f, 0.f, 0.5f),
                0,
                0,
                esp_box_thickness + 2,
                false
            );

            draw_rect_using_dimensions(
                draw_list,
                ImVec2(screen_head_origin_position_with_slight_offset.x - (width / 2), screen_head_origin_position_with_slight_offset.y),
                ImVec2(width, height),
                ImColor(1.f, 1.f, 1.f, 0.5f),
                0,
                0,
                esp_box_thickness,
                false
            );
        }
        if (globals::head_dot_enabled) {
            draw_list->AddCircleFilled(
                ImVec2(screen_head_origin_position.x, screen_head_origin_position.y),
                7500 / distance,
                ImColor(1.f, 0.f, 0.f, 0.25f),
                15
            );
        }
    }
}